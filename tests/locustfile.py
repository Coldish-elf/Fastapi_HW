from locust import HttpUser, User, task, between, events
import random
import time

BASE_URL = "http://localhost:8000"
DEFAULT_USER_PASSWORD = "locustpassword"

def generate_unique_username(prefix="locustuser_"):
    return f"{prefix}{int(time.time() * 1000)}_{random.randint(1000, 9999)}"

class AuthenticatedFastAPIUser(HttpUser):
    abstract = True
    host = BASE_URL
    auth_token = None
    user_credentials = {}

    def on_start(self):
        self.user_credentials = {
            "username": generate_unique_username(),
            "password": DEFAULT_USER_PASSWORD
        }
        
        response_register = self.client.post("/users", json=self.user_credentials)
        if response_register.status_code != 200 and response_register.status_code != 409:
            return

        response_token = self.client.post("/token", data=self.user_credentials)
        if response_token.status_code == 200:
            self.auth_token = response_token.json().get("access_token")
        else:
            self.auth_token = None

    def _get_auth_headers(self):
        if not self.auth_token:
            return None
        return {"Authorization": f"Bearer {self.auth_token}"}

class ReadHeavyUser(AuthenticatedFastAPIUser):
    wait_time = between(1, 5)

    @task(10)
    def get_tasks_with_filters(self):
        headers = self._get_auth_headers()
        if not headers: return

        params = {}
        if random.random() < 0.5: 
            params["sort_by"] = random.choice(["title", "status", "created_at", "priority", "id"])
        if random.random() < 0.4:
            params["search"] = random.choice(["task", "test", "important", "api", "locust"])
        if random.random() < 0.3:
            params["top"] = random.randint(1, 20)
        if random.random() < 0.2:
            params["status"] = random.choice(["в ожидании", "в работе", "завершено"])
        
        self.client.get("/tasks", headers=headers, params=params, name="/tasks (get with filters)")

    @task(2)
    def get_own_user_info(self):
        headers = self._get_auth_headers()
        if not headers: return
        self.client.get("/users/me", headers=headers, name="/users/me")


class WriteHeavyUser(AuthenticatedFastAPIUser):
    wait_time = between(0.5, 2)

    @task(5)
    def create_task(self):
        headers = self._get_auth_headers()
        if not headers: return

        task_data = {
            "title": f"WriteHeavy Task {random.randint(1, 10000)} by {self.user_credentials['username']}",
            "description": "Generated by WriteHeavyUser via Locust",
            "status": random.choice(["в ожидании", "в работе"]),
            "priority": random.randint(1, 10)
        }
        with self.client.post("/tasks", headers=headers, json=task_data, name="/tasks (post)", catch_response=True) as response:
            if not response.ok:
                response.failure(f"Create task failed: {response.status_code} - {response.text}")

    @task(2)
    def update_random_task(self):
        headers = self._get_auth_headers()
        if not headers: return
        
        with self.client.get("/tasks", headers=headers, params={"limit": 5}, name="/tasks (get for update)", catch_response=True) as response_get:
            if not response_get.ok:
                response_get.failure(f"Get for update failed: {response_get.status_code}")
                return
            try:
                tasks = response_get.json()
                if not tasks: 
                    response_get.success()
                    return
            except ValueError:
                response_get.failure(f"Get for update returned invalid JSON: {response_get.text}")
                return
            
            task_to_modify = random.choice(tasks)
            task_id = task_to_modify["id"]
            
            update_data = {
                "title": f"Updated Task {task_id} by {self.user_credentials['username']}",
                "description": "Updated by WriteHeavyUser",
                "status": random.choice(["в ожидании", "в работе", "завершено"]),
                "priority": random.randint(1, 10)
            }
            with self.client.put(f"/tasks/{task_id}", headers=headers, json=update_data, name="/tasks/{id} (put)", catch_response=True) as response_put:
                if not response_put.ok:
                    response_put.failure(f"Update task {task_id} failed: {response_put.status_code} - {response_put.text}")

    @task(1)
    def delete_random_task(self):
        headers = self._get_auth_headers()
        if not headers: return

        with self.client.get("/tasks", headers=headers, params={"limit": 5}, name="/tasks (get for delete)", catch_response=True) as response_get:
            if not response_get.ok:
                response_get.failure(f"Get for delete failed: {response_get.status_code}")
                return
            try:
                tasks = response_get.json()
                if not tasks:
                    response_get.success()
                    return
            except ValueError:
                response_get.failure(f"Get for delete returned invalid JSON: {response_get.text}")
                return

            task_to_delete = random.choice(tasks)
            task_id = task_to_delete["id"]
            with self.client.delete(f"/tasks/{task_id}", headers=headers, name="/tasks/{id} (delete)", catch_response=True) as response_delete:
                if not response_delete.ok:
                     response_delete.failure(f"Delete task {task_id} failed: {response_delete.status_code} - {response_delete.text}")

    @task(1)
    def test_list_cache_invalidation_after_create(self):
        headers = self._get_auth_headers()
        if not headers: return

        list_params = {"limit": 5, "sort_by": "created_at"} 

        new_task_title = f"CacheInvalidationList Task {random.randint(1, 10000)} by {self.user_credentials['username']}"
        create_data = {"title": new_task_title, "description": "Testing list cache invalidation", "status": "в ожидании", "priority": 1}
        new_task_id = None
        with self.client.post("/tasks", headers=headers, json=create_data, 
                              name="/tasks (list_cache_inval_post)", catch_response=True) as response_create:
            if not response_create.ok:
                response_create.failure(f"List_cache_inval_post failed: {response_create.status_code} - {response_create.text}")
                return 
            try:
                new_task_id = response_create.json()["id"]
            except (KeyError, TypeError, ValueError):
                response_create.failure(f"List_cache_inval_post did not return task ID: {response_create.text}")
                return
        
        time.sleep(0.2) 

        with self.client.get("/tasks", headers=headers, params=list_params, 
                             name="/tasks (list_cache_inval_get_after_create)", catch_response=True) as response_get_list:
            if not response_get_list.ok:
                response_get_list.failure(f"List_cache_inval_get_after_create failed: {response_get_list.status_code} - {response_get_list.text}")
                return
            try:
                updated_tasks = response_get_list.json()
                found_new_task = any(task["id"] == new_task_id for task in updated_tasks if isinstance(task, dict) and "id" in task)
                
                if not found_new_task:
                    response_get_list.failure(f"List_cache_inval_get_after_create: New task {new_task_id} not found in list.")
                else:
                    response_get_list.success()
            except (TypeError, KeyError, ValueError):
                response_get_list.failure(f"List_cache_inval_get_after_create returned invalid JSON: {response_get_list.text}")


class MixedUsageUser(AuthenticatedFastAPIUser):
    wait_time = between(1, 3)

    @task(10)
    def get_tasks(self):
        headers = self._get_auth_headers()
        if not headers: return
        
        params = {}
        if random.random() < 0.3: 
            params["sort_by"] = random.choice(["title", "status", "created_at", "priority"])
        if random.random() < 0.2:
            params["search"] = random.choice(["task", "test", "important", "api"])
        if random.random() < 0.1:
            params["top"] = random.randint(1, 10)
            
        self.client.get("/tasks", headers=headers, params=params, name="/tasks (mixed get)")

    @task(3)
    def create_task(self):
        headers = self._get_auth_headers()
        if not headers: return

        task_data = {
            "title": f"MixedUse Task {random.randint(1, 1000)}",
            "description": "Generated by MixedUsageUser",
            "status": random.choice(["в ожидании", "в работе", "завершено"]),
            "priority": random.randint(1, 10)
        }
        self.client.post("/tasks", headers=headers, json=task_data, name="/tasks (mixed post)")

    @task(1) 
    def update_or_delete_task(self):
        headers = self._get_auth_headers()
        if not headers: return
        
        tasks = []
        with self.client.get("/tasks", headers=headers, params={"limit": 5}, name="/tasks (mixed get for update/delete)", catch_response=True) as response_get:
            if not response_get.ok:
                response_get.failure(f"Mixed get for update/delete failed: {response_get.status_code}")
                return
            try:
                tasks = response_get.json()
                if not tasks: 
                    response_get.success()
                    return
            except ValueError:
                response_get.failure(f"Mixed get for update/delete returned invalid JSON: {response_get.text}")
                return
        
        if not tasks:
            return

        task_to_modify = random.choice(tasks)
        task_id = task_to_modify["id"]

        if random.random() < 0.7:
            update_data = {
                "title": f"Updated Mixed Task {task_id}",
                "description": "Updated by MixedUsageUser",
                "status": random.choice(["в ожидании", "в работе", "завершено"]),
                "priority": random.randint(1, 10)
            }
            with self.client.put(f"/tasks/{task_id}", headers=headers, json=update_data, name="/tasks/{id} (mixed put)", catch_response=True) as response_put:
                if not response_put.ok:
                    response_put.failure(f"Mixed update task {task_id} failed: {response_put.status_code} - {response_put.text}")
        else:
            with self.client.delete(f"/tasks/{task_id}", headers=headers, name="/tasks/{id} (mixed delete)", catch_response=True) as response_delete:
                if not response_delete.ok:
                    response_delete.failure(f"Mixed delete task {task_id} failed: {response_delete.status_code} - {response_delete.text}")


class CacheBenchmarkUser(AuthenticatedFastAPIUser):
    wait_time = between(0.5, 1.5)
    
    static_params_for_cache_test = {"sort_by": "created_at", "limit": 10, "status": "в ожидании"} 

    @task(5) 
    def get_tasks_with_static_params_for_cache_potential(self):
        headers = self._get_auth_headers()
        if not headers: return
        with self.client.get("/tasks", headers=headers, params=self.static_params_for_cache_test, 
                             name="/tasks (static_params_cache_potential)", catch_response=True) as response:
            if not response.ok:
                response.failure(f"Static params cache potential failed: {response.status_code} - {response.text}")

    @task(5)
    def get_tasks_repeatedly_for_cache_hit(self):
        headers = self._get_auth_headers()
        if not headers: return

        with self.client.get("/tasks", headers=headers, params=self.static_params_for_cache_test, 
                             name="/tasks (cache_hit_test_first_call)", catch_response=True) as response1:
            if not response1.ok:
                response1.failure(f"Cache_hit_test_first_call failed: {response1.status_code} - {response1.text}")
                return 
        

        with self.client.get("/tasks", headers=headers, params=self.static_params_for_cache_test, 
                             name="/tasks (cache_hit_test_second_call)", catch_response=True) as response2:
            if not response2.ok:
                response2.failure(f"Cache_hit_test_second_call failed: {response2.status_code} - {response2.text}")

    @task(5)
    def get_tasks_dynamic_params(self):
        headers = self._get_auth_headers()
        if not headers: return
        
        params = {
            "sort_by": random.choice(["title", "status", "priority", "id"]),
            "search": f"dyn_search_{random.randint(1,1000)}",  
            "top": random.randint(5, 15),
            "status": random.choice(["в ожидании", "в работе", "завершено"])
        }
        with self.client.get("/tasks", headers=headers, params=params, name="/tasks (dynamic get)", catch_response=True) as response:
            if not response.ok:
                response.failure(f"Dynamic get failed: {response.status_code} - {response.text}")

    @task(3)
    def get_tasks_with_no_cache_header(self):
        headers = self._get_auth_headers()
        if not headers: return

        no_cache_headers = headers.copy()
        no_cache_headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
        no_cache_headers["Pragma"] = "no-cache"
        no_cache_headers["Expires"] = "0"

        with self.client.get("/tasks", headers=no_cache_headers, params=self.static_params_for_cache_test, 
                             name="/tasks (no-cache header)", catch_response=True) as response:
            if not response.ok:
                response.failure(f"No-cache header get failed: {response.status_code} - {response.text}")

    def on_stop(self):
        pass


class APICreationStressUser(AuthenticatedFastAPIUser):
    wait_time = between(0.1, 0.5)

    @task(10)
    def stress_create_task(self):
        headers = self._get_auth_headers()
        if not headers: return

        task_data = {
            "title": f"Stress Test Task {random.randint(10000, 99999)} by {self.user_credentials['username']}",
            "description": "High-frequency task creation by APICreationStressUser",
            "status": "в ожидании",
            "priority": random.choice([1,2,3])
        }
        self.client.post("/tasks", headers=headers, json=task_data, name="/tasks (stress post)")

    @task(1)
    def quick_check_tasks(self):
        headers = self._get_auth_headers()
        if not headers: return
        self.client.get("/tasks", headers=headers, params={"limit": 1}, name="/tasks (stress quick check)")

@events.test_start.add_listener
def on_test_start(environment, **kwargs):
    pass

@events.test_stop.add_listener
def on_test_stop(environment, **kwargs):
    pass